"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[46058],{28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function c(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),s.createElement(i.Provider,{value:t},e.children)}},80597:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tuts/tutorials/programming/python/object-oriented-programming","title":"Object-Oriented Programming (OOP)","description":"Object-Oriented Programming (OOP) is a programming paradigm that focuses on creating objects that contain both data and behavior. Python fully supports OOP and allows you to define classes and create objects based on those classes. In this section, we\'ll cover the basic concepts of OOP in Python.","source":"@site/docs/tuts/tutorials/programming/python/4-oop.md","sourceDirName":"tuts/tutorials/programming/python","slug":"/tuts/tutorials/programming/python/object-oriented-programming","permalink":"/docs/tuts/tutorials/programming/python/object-oriented-programming","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Python","permalink":"/docs/tags/python"},{"inline":true,"label":"OOP","permalink":"/docs/tags/oop"},{"inline":true,"label":"Object-Oriented Programming","permalink":"/docs/tags/object-oriented-programming"}],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"id":"object-oriented-programming","title":"Object-Oriented Programming (OOP)","tags":["Python","OOP","Object-Oriented Programming"]}}');var a=n(74848),i=n(28453);const c={sidebar_position:4,id:"object-oriented-programming",title:"Object-Oriented Programming (OOP)",tags:["Python","OOP","Object-Oriented Programming"]},r=void 0,o={},d=[{value:"Classes and Objects",id:"classes-and-objects",level:3},{value:"Constructor",id:"constructor",level:3},{value:"Inheritance and Polymorphism",id:"inheritance-and-polymorphism",level:3},{value:"Encapsulation and Data Hiding",id:"encapsulation-and-data-hiding",level:3},{value:"Class methods and instance methods",id:"class-methods-and-instance-methods",level:3},{value:"Class Methods",id:"class-methods",level:4},{value:"Instance Methods",id:"instance-methods",level:4},{value:"Summary",id:"summary",level:3},{value:"Github Repo",id:"github-repo",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Object-Oriented Programming (OOP) is a programming paradigm that focuses on creating objects that contain both data and behavior. Python fully supports OOP and allows you to define classes and create objects based on those classes. In this section, we'll cover the basic concepts of OOP in Python."}),"\n",(0,a.jsx)(t.h3,{id:"classes-and-objects",children:"Classes and Objects"}),"\n",(0,a.jsx)(t.p,{children:"A class is a blueprint or template for creating objects. It defines the attributes (data) and methods (behavior) that the objects of the class will have. Here's an example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# Class definition\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n\n    def drive(self):\n        print("The car is driving.")\n\n    def stop(self):\n        print("The car has stopped.")\n\n    def display_info(self):\n        print(f"Car: {self.make} {self.model}, Year: {self.year}")\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the above code, we define a ",(0,a.jsx)(t.code,{children:"Car"})," class with attributes such as ",(0,a.jsx)(t.code,{children:"make"}),", ",(0,a.jsx)(t.code,{children:"model"}),", and ",(0,a.jsx)(t.code,{children:"year"}),". We also define three methods: ",(0,a.jsx)(t.code,{children:"drive()"}),", ",(0,a.jsx)(t.code,{children:"stop()"})," and ",(0,a.jsx)(t.code,{children:"display_info()"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["An object is an instance of a class. You can create multiple objects based on the same class, each with its own data. Here's how to create objects from the ",(0,a.jsx)(t.code,{children:"Car"})," class:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# Creating objects\ncar1 = Car("Ford", "Mustang", 2022)\ncar2 = Car("Tesla", "Model S", 2023)\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the above code, we create two objects (",(0,a.jsx)(t.code,{children:"car1"})," and ",(0,a.jsx)(t.code,{children:"car2"}),") from the ",(0,a.jsx)(t.code,{children:"Car"})," class. We pass the respective values for the ",(0,a.jsx)(t.code,{children:"make"}),", ",(0,a.jsx)(t.code,{children:"model"}),", and ",(0,a.jsx)(t.code,{children:"year"})," attributes."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"# Accessing attributes and calling methods\nprint(car1.make)  # Output: Ford\nprint(car1.model)  # Output: Mustang\nprint(car1.year)  # Output: 2022\ncar2.display_info()  # Output: Car: Tesla Model S, Year: 2023\n"})}),"\n",(0,a.jsxs)(t.p,{children:["we can access the attributes (",(0,a.jsx)(t.code,{children:"make"}),", ",(0,a.jsx)(t.code,{children:"model"}),", ",(0,a.jsx)(t.code,{children:"year"}),") using dot notation (",(0,a.jsx)(t.code,{children:"car1.make"}),", ",(0,a.jsx)(t.code,{children:"car1.model"}),", ",(0,a.jsx)(t.code,{children:"car1.year"}),"). We can also call the ",(0,a.jsx)(t.code,{children:"display_info()"})," method on the ",(0,a.jsx)(t.code,{children:"car1"})," or ",(0,a.jsx)(t.code,{children:"car2"})," objects to display information about the car."]}),"\n",(0,a.jsx)(t.h3,{id:"constructor",children:"Constructor"}),"\n",(0,a.jsxs)(t.p,{children:["In the above code (Class Car definition), the ",(0,a.jsx)(t.code,{children:"def __init__(self, make, model, year)"})," method is called the constructor. It is a special method that gets executed when an object of the class is created. The ",(0,a.jsx)(t.code,{children:"self"})," parameter represents the instance of the class being created."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"__init__"})," method allows us to initialize the attributes of the class. In this case, the ",(0,a.jsx)(t.code,{children:"make"}),", ",(0,a.jsx)(t.code,{children:"model"}),", and ",(0,a.jsx)(t.code,{children:"year"})," parameters are used to initialize the respective attributes of the ",(0,a.jsx)(t.code,{children:"Car"})," class."]}),"\n",(0,a.jsxs)(t.p,{children:["Inside the ",(0,a.jsx)(t.code,{children:"__init__"})," method, we assign the parameter values to the instance variables using the ",(0,a.jsx)(t.code,{children:"self"})," keyword. These instance variables (",(0,a.jsx)(t.code,{children:"self.make"}),", ",(0,a.jsx)(t.code,{children:"self.model"}),", ",(0,a.jsx)(t.code,{children:"self.year"}),") store the data specific to each instance of the class."]}),"\n",(0,a.jsxs)(t.p,{children:["By defining the ",(0,a.jsx)(t.code,{children:"__init__"})," method, we ensure that whenever a new ",(0,a.jsx)(t.code,{children:"Car"})," object is created, it requires the ",(0,a.jsx)(t.code,{children:"make"}),", ",(0,a.jsx)(t.code,{children:"model"}),", and ",(0,a.jsx)(t.code,{children:"year"})," values to be provided. This helps in ensuring that all ",(0,a.jsx)(t.code,{children:"Car"})," objects are properly initialized with the necessary data."]}),"\n",(0,a.jsxs)(t.p,{children:["Later in the code, after creating an instance of the ",(0,a.jsx)(t.code,{children:"Car"})," class (",(0,a.jsx)(t.code,{children:"car1"}),"), we can access the attributes (",(0,a.jsx)(t.code,{children:"make"}),", ",(0,a.jsx)(t.code,{children:"model"}),", ",(0,a.jsx)(t.code,{children:"year"}),") using dot notation (",(0,a.jsx)(t.code,{children:"car1.make"}),", ",(0,a.jsx)(t.code,{children:"car1.model"}),", ",(0,a.jsx)(t.code,{children:"car1.year"}),"). We can also call the ",(0,a.jsx)(t.code,{children:"display_info()"})," method on the ",(0,a.jsx)(t.code,{children:"car1"})," or ",(0,a.jsx)(t.code,{children:"car2"})," objects to display information about the car."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"__init__"})," method is a fundamental part of defining classes and objects in Python. It allows us to initialize the state of objects and customize their creation process."]}),"\n",(0,a.jsx)(t.h3,{id:"inheritance-and-polymorphism",children:"Inheritance and Polymorphism"}),"\n",(0,a.jsx)(t.p,{children:"Inheritance is a fundamental concept in OOP that allows you to create new classes based on existing classes. The new class, called a subclass or derived class, inherits the attributes and methods of the existing class, called the superclass or base class. This promotes code reuse and allows for hierarchical relationships between classes."}),"\n",(0,a.jsx)(t.p,{children:"Here's an example demonstrating inheritance:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# Inheritance\nclass ElectricCar(Car):\n    def __init__(self, make, model, year, battery_capacity):\n        super().__init__(make, model, year)\n        self.battery_capacity = battery_capacity\n\n    def charge(self):\n        print("The electric car is charging.")\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the above code, we define a new class ",(0,a.jsx)(t.code,{children:"ElectricCar"}),", which is a subclass of ",(0,a.jsx)(t.code,{children:"Car"}),". The ",(0,a.jsx)(t.code,{children:"ElectricCar"})," class inherits the attributes and methods from ",(0,a.jsx)(t.code,{children:"Car"})," using the ",(0,a.jsx)(t.code,{children:"super()"})," function. Additionally, the ",(0,a.jsx)(t.code,{children:"ElectricCar"})," class has its own attribute ",(0,a.jsx)(t.code,{children:"battery_capacity"})," and a method ",(0,a.jsx)(t.code,{children:"charge()"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Polymorphism"})," is the ability of an object to take different forms or behave differently based on the context. In Python, polymorphism is achieved through method overriding and method overloading. Method overriding allows a subclass to provide a different implementation of a method defined in its superclass. Method overloading, however, is not directly supported in Python."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'# Method Overriding\nclass ElectricCar(Car):\n    def __init__(self, make, model, year, battery_capacity):\n        super().__init__(make, model, year)\n        self.battery_capacity = battery_capacity\n\n    def charge(self):\n        print("The electric car is charging.")\n    \n    # Overriding base class method \n    def display_info(self):\n        print(f"Car: {self.make} {self.model}, Year: {self.year}, BatteryCapacity: {self.battery_capacity}")\n'})}),"\n",(0,a.jsx)(t.h3,{id:"encapsulation-and-data-hiding",children:"Encapsulation and Data Hiding"}),"\n",(0,a.jsx)(t.p,{children:"Encapsulation is the bundling of data and methods within a class, where the internal details are hidden from the outside. This is achieved by using access modifiers such as public, private, and protected. In Python, the concept of data hiding is achieved through naming conventions and conventions around attribute access."}),"\n",(0,a.jsxs)(t.p,{children:["Attributes or methods that are intended to be private are prefixed with an underscore ",(0,a.jsx)(t.code,{children:"_"}),", indicating that they should not be accessed directly from outside the class. However, there are no strict restrictions in Python to prevent accessing these attributes. It's more of a convention to indicate that those members are intended for internal use."]}),"\n",(0,a.jsx)(t.h3,{id:"class-methods-and-instance-methods",children:"Class methods and instance methods"}),"\n",(0,a.jsx)(t.p,{children:"In Object-Oriented Programming (OOP), class methods and instance methods are two types of methods that can be defined within a class to perform specific tasks."}),"\n",(0,a.jsx)(t.h4,{id:"class-methods",children:"Class Methods"}),"\n",(0,a.jsxs)(t.p,{children:["Class methods are methods that are bound to the class itself rather than its instances. They are defined using the ",(0,a.jsx)(t.code,{children:"@classmethod"})," decorator and take the class itself (",(0,a.jsx)(t.code,{children:"cls"}),") as the first parameter. Class methods can be used to access or modify class-level attributes and perform operations that are relevant to the entire class."]}),"\n",(0,a.jsx)(t.p,{children:"Here's an example that demonstrates the usage of a class method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"class Circle:\n    PI = 3.14159  # Class-level attribute\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    @classmethod\n    def from_diameter(cls, diameter):\n        radius = diameter / 2\n        return cls(radius)\n\n    def calculate_area(self):\n        return self.PI * self.radius * self.radius\n\n# Creating an instance using a class method\ncircle = Circle.from_diameter(10)\n\n# Accessing instance attribute and invoking an instance method\nprint(circle.radius)  # Output: 5.0\nprint(circle.calculate_area())  # Output: 78.53975\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In the above code, the ",(0,a.jsx)(t.code,{children:"from_diameter()"})," method is a class method that creates a Circle object based on the diameter instead of the radius. It takes the class itself (",(0,a.jsx)(t.code,{children:"cls"}),") as the first parameter and returns a new instance of the class (",(0,a.jsx)(t.code,{children:"cls(radius)"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["By using the ",(0,a.jsx)(t.code,{children:"@classmethod"})," decorator, we can define this method as a class method, allowing it to be called on the class itself (",(0,a.jsx)(t.code,{children:"Circle.from_diameter(10)"}),") rather than an instance."]}),"\n",(0,a.jsx)(t.h4,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,a.jsxs)(t.p,{children:["Instance methods are methods that are bound to the instances of a class. They are the most common type of methods in OOP. Instance methods have access to the instance itself (referred to as ",(0,a.jsx)(t.code,{children:"self"}),") and can operate on instance attributes and perform actions specific to each instance."]}),"\n",(0,a.jsx)(t.p,{children:"Here's an example that demonstrates the usage of an instance method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def calculate_area(self):\n        return self.width * self.height\n\n# Creating instances of the Rectangle class\nrectangle1 = Rectangle(5, 10)\nrectangle2 = Rectangle(3, 6)\n\n# Invoking the instance method on each instance\nprint(rectangle1.calculate_area())  # Output: 50\nprint(rectangle2.calculate_area())  # Output: 18\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In the above code, the ",(0,a.jsx)(t.code,{children:"calculate_area()"})," method is an instance method defined within the ",(0,a.jsx)(t.code,{children:"Rectangle"})," class. It calculates the area of the rectangle based on the width and height attributes of the instance (",(0,a.jsx)(t.code,{children:"self"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["To invoke an instance method, we call it on an instance of the class (",(0,a.jsx)(t.code,{children:"rectangle1.calculate_area()"}),", ",(0,a.jsx)(t.code,{children:"rectangle2.calculate_area()"}),"). The instance (",(0,a.jsx)(t.code,{children:"self"}),") is automatically passed as the first parameter when calling the method."]}),"\n",(0,a.jsx)(t.p,{children:"Instance methods allow objects to perform actions and interact with their own data, providing a way to encapsulate behavior within each instance of a class."}),"\n",(0,a.jsx)(t.p,{children:"Both class methods and instance methods play important roles in defining the behavior and functionality of classes in Object-Oriented Programming. By understanding and utilizing these methods effectively, you can create more flexible and powerful class designs."}),"\n",(0,a.jsx)(t.h3,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(t.p,{children:"In this section, we explored the basics of Object-Oriented Programming in Python. We learned about classes, objects, inheritance, polymorphism, encapsulation, and data hiding. Understanding these concepts is crucial for building complex and scalable applications. In the next section, we'll delve into modules and packages in Python."}),"\n",(0,a.jsx)(t.h3,{id:"github-repo",children:"Github Repo"}),"\n",(0,a.jsxs)(t.admonition,{type:"info",children:[(0,a.jsxs)(t.p,{children:["You can refer to and clone the code samples for this tutorial from the ",(0,a.jsx)(t.a,{href:"https://github.com/certifysphere/python-code-samples",children:"GitHub repository"}),"."]}),(0,a.jsx)(t.p,{children:"To clone the repository, you can use the following command:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"git clone https://github.com/certifysphere/python-code-samples.git\n"})}),(0,a.jsxs)(t.p,{children:["You can then navigate to the ",(0,a.jsx)(t.code,{children:"/src"})," directory to access all the code samples given in this tutorial."]})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);